// DO NOT EDIT! This file was auto-generated by crates/build/re_types_builder/src/codegen/rust/api.rs
// Based on "crates/store/re_types/definitions/rerun/archetypes/leaf_transforms3d.fbs".

#![allow(unused_imports)]
#![allow(unused_parens)]
#![allow(clippy::clone_on_copy)]
#![allow(clippy::cloned_instead_of_copied)]
#![allow(clippy::map_flatten)]
#![allow(clippy::needless_question_mark)]
#![allow(clippy::new_without_default)]
#![allow(clippy::redundant_closure)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::too_many_lines)]

use ::re_types_core::external::arrow2;
use ::re_types_core::ComponentName;
use ::re_types_core::SerializationResult;
use ::re_types_core::{ComponentBatch, MaybeOwnedComponentBatch};
use ::re_types_core::{DeserializationError, DeserializationResult};

/// **Archetype**: One or more transforms between the parent and the current entity which are *not* propagated in the transform hierarchy.
///
/// For transforms that are propagated in the transform hierarchy, see [`archetypes.Transform3D`].
///
/// From the point of view of the entity's coordinate system,
/// all components are applied in the inverse order they are listed here.
/// E.g. if both a translation and a max3x3 transform are present,
/// the 3x3 matrix is applied first, followed by the translation.
#[derive(Clone, Debug, Default, PartialEq)]
pub struct LeafTransforms3D {
    /// Translation vectors.
    pub translation: Option<Vec<crate::components::LeafTranslation3D>>,

    /// Rotations via axis + angle.
    pub rotation_axis_angle: Option<Vec<crate::components::LeafRotationAxisAngle>>,

    /// Rotations via quaternion.
    pub quaternion: Option<Vec<crate::components::LeafRotationQuat>>,

    /// Scaling factor.
    pub scale: Option<Vec<crate::components::LeafScale3D>>,

    /// 3x3 transformation matrix.
    pub mat3x3: Option<Vec<crate::components::LeafTransformMat3x3>>,
}

impl ::re_types_core::SizeBytes for LeafTransforms3D {
    #[inline]
    fn heap_size_bytes(&self) -> u64 {
        self.translation.heap_size_bytes()
            + self.rotation_axis_angle.heap_size_bytes()
            + self.quaternion.heap_size_bytes()
            + self.scale.heap_size_bytes()
            + self.mat3x3.heap_size_bytes()
    }

    #[inline]
    fn is_pod() -> bool {
        <Option<Vec<crate::components::LeafTranslation3D>>>::is_pod()
            && <Option<Vec<crate::components::LeafRotationAxisAngle>>>::is_pod()
            && <Option<Vec<crate::components::LeafRotationQuat>>>::is_pod()
            && <Option<Vec<crate::components::LeafScale3D>>>::is_pod()
            && <Option<Vec<crate::components::LeafTransformMat3x3>>>::is_pod()
    }
}

static REQUIRED_COMPONENTS: once_cell::sync::Lazy<[ComponentName; 0usize]> =
    once_cell::sync::Lazy::new(|| []);

static RECOMMENDED_COMPONENTS: once_cell::sync::Lazy<[ComponentName; 1usize]> =
    once_cell::sync::Lazy::new(|| ["rerun.components.LeafTransforms3DIndicator".into()]);

static OPTIONAL_COMPONENTS: once_cell::sync::Lazy<[ComponentName; 5usize]> =
    once_cell::sync::Lazy::new(|| {
        [
            "rerun.components.LeafTranslation3D".into(),
            "rerun.components.LeafRotationAxisAngle".into(),
            "rerun.components.LeafRotationQuat".into(),
            "rerun.components.LeafScale3D".into(),
            "rerun.components.LeafTransformMat3x3".into(),
        ]
    });

static ALL_COMPONENTS: once_cell::sync::Lazy<[ComponentName; 6usize]> =
    once_cell::sync::Lazy::new(|| {
        [
            "rerun.components.LeafTransforms3DIndicator".into(),
            "rerun.components.LeafTranslation3D".into(),
            "rerun.components.LeafRotationAxisAngle".into(),
            "rerun.components.LeafRotationQuat".into(),
            "rerun.components.LeafScale3D".into(),
            "rerun.components.LeafTransformMat3x3".into(),
        ]
    });

impl LeafTransforms3D {
    /// The total number of components in the archetype: 0 required, 1 recommended, 5 optional
    pub const NUM_COMPONENTS: usize = 6usize;
}

/// Indicator component for the [`LeafTransforms3D`] [`::re_types_core::Archetype`]
pub type LeafTransforms3DIndicator = ::re_types_core::GenericIndicatorComponent<LeafTransforms3D>;

impl ::re_types_core::Archetype for LeafTransforms3D {
    type Indicator = LeafTransforms3DIndicator;

    #[inline]
    fn name() -> ::re_types_core::ArchetypeName {
        "rerun.archetypes.LeafTransforms3D".into()
    }

    #[inline]
    fn display_name() -> &'static str {
        "Leaf transforms 3D"
    }

    #[inline]
    fn indicator() -> MaybeOwnedComponentBatch<'static> {
        static INDICATOR: LeafTransforms3DIndicator = LeafTransforms3DIndicator::DEFAULT;
        MaybeOwnedComponentBatch::Ref(&INDICATOR)
    }

    #[inline]
    fn required_components() -> ::std::borrow::Cow<'static, [ComponentName]> {
        REQUIRED_COMPONENTS.as_slice().into()
    }

    #[inline]
    fn recommended_components() -> ::std::borrow::Cow<'static, [ComponentName]> {
        RECOMMENDED_COMPONENTS.as_slice().into()
    }

    #[inline]
    fn optional_components() -> ::std::borrow::Cow<'static, [ComponentName]> {
        OPTIONAL_COMPONENTS.as_slice().into()
    }

    #[inline]
    fn all_components() -> ::std::borrow::Cow<'static, [ComponentName]> {
        ALL_COMPONENTS.as_slice().into()
    }

    #[inline]
    fn from_arrow_components(
        arrow_data: impl IntoIterator<Item = (ComponentName, Box<dyn arrow2::array::Array>)>,
    ) -> DeserializationResult<Self> {
        re_tracing::profile_function!();
        use ::re_types_core::{Loggable as _, ResultExt as _};
        let arrays_by_name: ::std::collections::HashMap<_, _> = arrow_data
            .into_iter()
            .map(|(name, array)| (name.full_name(), array))
            .collect();
        let translation =
            if let Some(array) = arrays_by_name.get("rerun.components.LeafTranslation3D") {
                Some({
                    <crate::components::LeafTranslation3D>::from_arrow_opt(&**array)
                        .with_context("rerun.archetypes.LeafTransforms3D#translation")?
                        .into_iter()
                        .map(|v| v.ok_or_else(DeserializationError::missing_data))
                        .collect::<DeserializationResult<Vec<_>>>()
                        .with_context("rerun.archetypes.LeafTransforms3D#translation")?
                })
            } else {
                None
            };
        let rotation_axis_angle =
            if let Some(array) = arrays_by_name.get("rerun.components.LeafRotationAxisAngle") {
                Some({
                    <crate::components::LeafRotationAxisAngle>::from_arrow_opt(&**array)
                        .with_context("rerun.archetypes.LeafTransforms3D#rotation_axis_angle")?
                        .into_iter()
                        .map(|v| v.ok_or_else(DeserializationError::missing_data))
                        .collect::<DeserializationResult<Vec<_>>>()
                        .with_context("rerun.archetypes.LeafTransforms3D#rotation_axis_angle")?
                })
            } else {
                None
            };
        let quaternion =
            if let Some(array) = arrays_by_name.get("rerun.components.LeafRotationQuat") {
                Some({
                    <crate::components::LeafRotationQuat>::from_arrow_opt(&**array)
                        .with_context("rerun.archetypes.LeafTransforms3D#quaternion")?
                        .into_iter()
                        .map(|v| v.ok_or_else(DeserializationError::missing_data))
                        .collect::<DeserializationResult<Vec<_>>>()
                        .with_context("rerun.archetypes.LeafTransforms3D#quaternion")?
                })
            } else {
                None
            };
        let scale = if let Some(array) = arrays_by_name.get("rerun.components.LeafScale3D") {
            Some({
                <crate::components::LeafScale3D>::from_arrow_opt(&**array)
                    .with_context("rerun.archetypes.LeafTransforms3D#scale")?
                    .into_iter()
                    .map(|v| v.ok_or_else(DeserializationError::missing_data))
                    .collect::<DeserializationResult<Vec<_>>>()
                    .with_context("rerun.archetypes.LeafTransforms3D#scale")?
            })
        } else {
            None
        };
        let mat3x3 = if let Some(array) = arrays_by_name.get("rerun.components.LeafTransformMat3x3")
        {
            Some({
                <crate::components::LeafTransformMat3x3>::from_arrow_opt(&**array)
                    .with_context("rerun.archetypes.LeafTransforms3D#mat3x3")?
                    .into_iter()
                    .map(|v| v.ok_or_else(DeserializationError::missing_data))
                    .collect::<DeserializationResult<Vec<_>>>()
                    .with_context("rerun.archetypes.LeafTransforms3D#mat3x3")?
            })
        } else {
            None
        };
        Ok(Self {
            translation,
            rotation_axis_angle,
            quaternion,
            scale,
            mat3x3,
        })
    }
}

impl ::re_types_core::AsComponents for LeafTransforms3D {
    fn as_component_batches(&self) -> Vec<MaybeOwnedComponentBatch<'_>> {
        re_tracing::profile_function!();
        use ::re_types_core::Archetype as _;
        [
            Some(Self::indicator()),
            self.translation
                .as_ref()
                .map(|comp_batch| (comp_batch as &dyn ComponentBatch).into()),
            self.rotation_axis_angle
                .as_ref()
                .map(|comp_batch| (comp_batch as &dyn ComponentBatch).into()),
            self.quaternion
                .as_ref()
                .map(|comp_batch| (comp_batch as &dyn ComponentBatch).into()),
            self.scale
                .as_ref()
                .map(|comp_batch| (comp_batch as &dyn ComponentBatch).into()),
            self.mat3x3
                .as_ref()
                .map(|comp_batch| (comp_batch as &dyn ComponentBatch).into()),
        ]
        .into_iter()
        .flatten()
        .collect()
    }
}

impl ::re_types_core::ArchetypeReflectionMarker for LeafTransforms3D {}

impl LeafTransforms3D {
    /// Create a new `LeafTransforms3D`.
    #[inline]
    pub fn new() -> Self {
        Self {
            translation: None,
            rotation_axis_angle: None,
            quaternion: None,
            scale: None,
            mat3x3: None,
        }
    }

    /// Translation vectors.
    #[inline]
    pub fn with_translation(
        mut self,
        translation: impl IntoIterator<Item = impl Into<crate::components::LeafTranslation3D>>,
    ) -> Self {
        self.translation = Some(translation.into_iter().map(Into::into).collect());
        self
    }

    /// Rotations via axis + angle.
    #[inline]
    pub fn with_rotation_axis_angle(
        mut self,
        rotation_axis_angle: impl IntoIterator<
            Item = impl Into<crate::components::LeafRotationAxisAngle>,
        >,
    ) -> Self {
        self.rotation_axis_angle = Some(rotation_axis_angle.into_iter().map(Into::into).collect());
        self
    }

    /// Rotations via quaternion.
    #[inline]
    pub fn with_quaternion(
        mut self,
        quaternion: impl IntoIterator<Item = impl Into<crate::components::LeafRotationQuat>>,
    ) -> Self {
        self.quaternion = Some(quaternion.into_iter().map(Into::into).collect());
        self
    }

    /// Scaling factor.
    #[inline]
    pub fn with_scale(
        mut self,
        scale: impl IntoIterator<Item = impl Into<crate::components::LeafScale3D>>,
    ) -> Self {
        self.scale = Some(scale.into_iter().map(Into::into).collect());
        self
    }

    /// 3x3 transformation matrix.
    #[inline]
    pub fn with_mat3x3(
        mut self,
        mat3x3: impl IntoIterator<Item = impl Into<crate::components::LeafTransformMat3x3>>,
    ) -> Self {
        self.mat3x3 = Some(mat3x3.into_iter().map(Into::into).collect());
        self
    }
}
